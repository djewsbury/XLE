// Copyright 2015 XLGAMES Inc.
//
// Distributed under the MIT License (See
// accompanying file "LICENSE" or the website
// http://www.opensource.org/licenses/mit-license.php)

#if !defined(UTILITY_MISC_H)
#define UTILITY_MISC_H

#pragma selector_filtering(push_disable)

#if !defined(LOOP_DIRECTIVE)
    #define LOOP_DIRECTIVE [loop]
#endif

#if !defined(BRANCH_DIRECTIVE)
    #define BRANCH_DIRECTIVE [branch]
#endif

#pragma selector_filtering(pop)

float Sq(float x) { return x*x; }

uint IntegerHash(uint seed)
{
		// From http://www.concentric.net/~Ttwang/tech/inthash.htm
		// This produces an output integer from an input integer,
		// where the bits of the output are generally unrelated to
		// the input, but there is a near 1:1 mapping from input to
		// output.
		// So if the input numbers have some ordering, this output
		// will be scrambled in the output.
		// In our case, the input seed numbers have a clear arrangement
		// in screen space XY. This could result in noticeable patterns.
		// When we scramble them through this hashing function, we should
		// remove patterns.
		//
		// We can find potentially cheaper implementations of the same
		// concept here:
		//		https://gist.github.com/badboy/6267743
		// Note that the constants below may not have a big effect on the
		// algorithm; but it's possible that there is some ideal set of
		// numbers that are least likely to produce patterns.
#if 1
	seed = (seed+0x7ed55d16u) + (seed<<12);
	seed = (seed^0xc761c23cu) ^ (seed>>19);
	seed = (seed+0x165667b1u) + (seed<<5);
	seed = (seed+0xd3a2646cu) ^ (seed<<9);
	seed = (seed+0xfd7046c5u) + (seed<<3);
	seed = (seed^0xb55a4f09u) ^ (seed>>16);
	return seed;
#else
	// this might give a more evenly scrambled result
	uint c2=0x27d4eb2d; // a prime or an odd constant
	seed = (seed ^ 61) ^ (seed >> 16);
	seed = seed + (seed << 3);
	seed = seed ^ (seed >> 4);
	seed = seed * c2;
	seed = seed ^ (seed >> 15);
	return seed;
#endif
}

uint32_t IntegerHashSimple(uint32_t x)
{
	// Generated by Claude 3.5
	x = ((x >> 16) ^ x) * 0x45d9f3b;
	x = ((x >> 16) ^ x) * 0x45d9f3b;
	x = (x >> 16) ^ x;
	return x;
}

uint32_t IntegerHashSimpleReverse(uint32_t x)
{
	// Generated by Claude 3.5
    x = ((x >> 16) ^ x) * 0x119de1f3;
    x = ((x >> 16) ^ x) * 0x119de1f3;
    x = (x >> 16) ^ x;
    return x;
}

uint32_t IntegerHashLowBits(uint32_t x)
{
	// Generated by Claude 3.5
	// Intended for sparse data structures where the lower 20 bits of 'x' generally
	// Can't be reversed
	// contain the most relevent data
    // More aggressive bit mixing that avoids simple XOR equivalence
    x += x << 11;     // Add left-shifted value, avoiding simple XOR
    x ^= x >> 7;      // Mix in asymmetric bit shift
    x += x << 15;     // Another asymmetric mixing step
    x ^= x >> 13;     // Complementary bit mixing
    x *= 0x1a85ca53;  // Prime multiplier for final scrambling
    return x;
}

uint InterleaveNibbles(uint2 xy)
{
	xy.x = (xy.x | (xy.x << 8)) & 0x00FF00FF;
	xy.x = (xy.x | (xy.x << 4)) & 0x0F0F0F0F;

	xy.y = (xy.y | (xy.y << 8)) & 0x00FF00FF;
	xy.y = (xy.y | (xy.y << 4)) & 0x0F0F0F0F;

	return xy.x | (xy.y << 4u);
}

uint InterleaveBits(uint2 xy)
{
	xy.x = (xy.x | (xy.x << 8u)) & 0x00FF00FFu;
	xy.x = (xy.x | (xy.x << 4u)) & 0x0F0F0F0Fu;
	xy.x = (xy.x | (xy.x << 2u)) & 0x33333333u;
	xy.x = (xy.x | (xy.x << 1u)) & 0x55555555u;

	xy.y = (xy.y | (xy.y << 8u)) & 0x00FF00FFu;
	xy.y = (xy.y | (xy.y << 4u)) & 0x0F0F0F0Fu;
	xy.y = (xy.y | (xy.y << 2u)) & 0x33333333u;
	xy.y = (xy.y | (xy.y << 1u)) & 0x55555555u;

	return xy.x | (xy.y << 1u);
}

int CountTrue(bool3 input)
{
	return dot(float(true).xxx, input);
}

uint DitherPatternInt(uint2 pixelCoords)
{
	// 
	// This is a custom dithering matrix (no error diffusion) that I arranged by scrambling the numbers
	// until I got a nice visual result.
	//
	// For reference, a commonly used matrix is the Bayer matrix:
	// uint ditherArray[16] =
	// {
	// 	0, 8, 2, 10,
	// 	12, 4, 14, 6,
	// 	3, 11, 1, 9,
	// 	15, 7, 13, 5
	// };
	// (see also BayerDitherPatternInt below)
	// 
	uint ditherArray[16] =
	{
		4, 12,  0,  8,
		10,  2, 14,  6,
		15,  7, 11,  3,
		1,  9,  5, 13
	};
	uint2 t = pixelCoords.xy & 0x3;
	return ditherArray[t.x+t.y*4];
}

uint BayerDitherPatternInt(uint2 pixelCoords, uint log2n)
{
	// Elegant way to calculate the bayer matrix in bit math
	// However, there's quite a bit of bit twiddling, so performance may not be ideal
	// (unless you already had interleaved pixelCoords.xy, perhaps)
	// "BayerDitherPatternInt(xy, 4u) / 256.f" gives you a 16x16 matrix with values between 0.f and 1.f
	pixelCoords.xy = pixelCoords.xy & ((1u<<log2n)-1u);
	return reversebits(InterleaveBits(uint2(pixelCoords.x^pixelCoords.y, pixelCoords.x))) >> (32u-log2n-log2n);
}

float DitherPatternValue(uint2 pixelCoords)
{
	return float(DitherPatternInt(pixelCoords)) / 16.f;
}

// xoshiro128+ generator. Intended for generating 32 bit floats (since the lowest four bits have low linear complexity)
// From the authors: We suggest to use a sign test to extract a random Boolean value, and right shifts to extract subsets of bits.
// See source: https://prng.di.unimi.it/xoshiro128plus.c
// Note that the authors have placed the above source into the public domain
// Ideally we should initialize using values produced from another rng (they should never all be zeroes)

static inline uint rotl32(uint x, uint k) { return (x << k) | (x >> (32u - k)); }

struct RNGState { uint s[4]; };

uint RNGNext(inout RNGState state)
{
	const uint result = state.s[0] + state.s[3];
	const uint t = state.s[1] << 9u;

	state.s[2] ^= state.s[0];
	state.s[3] ^= state.s[1];
	state.s[1] ^= state.s[2];
	state.s[0] ^= state.s[3];

	state.s[2] ^= t;

	state.s[3] = rotl32(state.s[3], 11u);

	return result;
}

float RNGNextF(inout RNGState state)
{
	uint i = RNGNext(state);
	// return i / float(0xffffffff);

	// Below uses the simple principle described at the bottom of https://prng.di.unimi.it/
	// Note that "float" must be a 32 bit type for this to work (and at least roughly ieee)
	// If we don't know the precision of float, we must use another method
	return asfloat((0x7fu << 23u) | (i>>9u)) - 1.0;
}

void RNGInitialize(out RNGState state, uint a, uint b, uint c, uint d)
{
	state.s[0] = a;
	state.s[1] = b;
	state.s[2] = c;
	state.s[3] = d;
}

#endif
