// Distributed under the MIT License (See
// accompanying file "LICENSE" or the website
// http://www.opensource.org/licenses/mit-license.php)

#pragma once

#include "SimpleModelDeform.h"
#include "../Format.h"
#include "../Types.h"
#include "../Assets/ModelScaffold.h"
#include "../Assets/ModelScaffoldInternal.h"
#include "../Assets/ModelImmutableData.h"
#include "../../Assets/IFileSystem.h"
#include "../GeoProc/MeshDatabase.h"        // for GeoProc::Copy
#include "../../Utility/MemoryUtils.h"
#include <memory>
#include <vector>

namespace RenderCore { namespace Techniques 
{
    namespace Internal
	{
        static constexpr unsigned VB_StaticData = 0;
    	static constexpr unsigned VB_TemporaryDeform = 1;
	    static constexpr unsigned VB_PostDeform = 2;

		struct SourceDataTransform
		{
			unsigned	_geoId;
			uint64_t	_sourceStream;
			Format		_targetFormat;
			unsigned	_targetOffset;
			unsigned	_targetStride;
			unsigned	_vertexCount;
		};

        struct DeformOp
        {
            std::shared_ptr<IDeformOperation> _deformOp;

            struct Element { Format _format = Format(0); unsigned _offset = 0; unsigned _stride = 0; unsigned _vbIdx = ~0u; };
            std::vector<Element> _inputElements;
            std::vector<Element> _outputElements;
        };

		struct NascentDeformStream
		{
			std::vector<DeformOp> _deformOps;

            RendererGeoDeformInterface _rendererInterf;
            std::vector<SourceDataTransform> _staticDataLoadRequests;

			unsigned _vbOffsets[3] = {0,0,0};
			unsigned _vbSizes[3] = {0,0,0};
		};

		static NascentDeformStream BuildNascentDeformStream(
			IteratorRange<const DeformOperationInstantiation*> globalDeformAttachments,
			unsigned geoId,
			unsigned vertexCount,
			unsigned& preDeformStaticDataVBIterator,
			unsigned& deformTemporaryVBIterator,
			unsigned& postDeformVBIterator)
		{
			// Calculate which elements are suppressed by the deform operations
			// We can only support a single deform operation per geo
			std::vector<const DeformOperationInstantiation*> deformAttachments;
			for (const auto& def:globalDeformAttachments)
				if (def._geoId == geoId) {
					deformAttachments.push_back(&def);
				}

			if (!deformAttachments.size()) return {};

			std::vector<uint64_t> workingSuppressedElements;
			std::vector<std::pair<DeformOperationInstantiation::NameAndFormat, unsigned>> workingGeneratedElements;
			std::vector<std::pair<DeformOperationInstantiation::NameAndFormat, unsigned>> workingTemporarySpaceElements;
			std::vector<std::pair<DeformOperationInstantiation::NameAndFormat, unsigned>> workingSourceDataElements;
			unsigned nextStreamId = 0;

			struct WorkingDeformOp
			{
				std::shared_ptr<IDeformOperation> _deformOp;
				std::vector<unsigned> _inputStreamIds;
				std::vector<unsigned> _outputStreamIds;
			};
			std::vector<WorkingDeformOp> workingDeformOps;

			for (auto d=deformAttachments.begin(); d!=deformAttachments.end(); ++d) {
				const auto&def = **d;
				WorkingDeformOp workingDeformOp;

				for (auto&e:def._upstreamSourceElements) {
					// find a matching source element generated from another deform op
					auto i = std::find_if(
						workingGeneratedElements.begin(), workingGeneratedElements.end(),
						[e](const std::pair<DeformOperationInstantiation::NameAndFormat, unsigned>& wge) {
							return wge.first._semantic == e._semantic && wge.first._semanticIndex == e._semanticIndex;
						});
					if (i != workingGeneratedElements.end()) {
						assert(i->first._format == e._format);
						workingDeformOp._inputStreamIds.push_back(i->second);
						workingTemporarySpaceElements.push_back(*i);
						workingGeneratedElements.erase(i);
					} else {
						// If it's not generated by some deform op, we look for it in the static data
						auto streamId = nextStreamId++;
						workingDeformOp._inputStreamIds.push_back(streamId);
						workingSourceDataElements.push_back(std::make_pair(e, streamId));
					}
				}

				// Before we add our own static data, we should remove any working elements that have been
				// suppressed
				auto i = std::remove_if(
					workingGeneratedElements.begin(), workingGeneratedElements.end(),
					[&def](const std::pair<DeformOperationInstantiation::NameAndFormat, unsigned>& wge) {
						auto hash = Hash64(wge.first._semantic) + wge.first._semanticIndex;
						return (std::find(def._suppressElements.begin(), def._suppressElements.end(), hash) != def._suppressElements.end())
							|| std::find(def._generatedElements.begin(), def._generatedElements.end(), wge.first) != def._generatedElements.end();
					});
				workingGeneratedElements.erase(i, workingGeneratedElements.end());		// these get removed and don't go into temporary space. They are just never used

				for (auto e=def._generatedElements.begin(); e!=def._generatedElements.end(); ++e) {
					auto streamId = nextStreamId++;
					workingGeneratedElements.push_back(std::make_pair(*e, streamId));
					workingDeformOp._outputStreamIds.push_back(streamId);
				}

				workingSuppressedElements.insert(
					workingSuppressedElements.end(),
					def._suppressElements.begin(), def._suppressElements.end());

				workingDeformOp._deformOp = def._operation;
				workingDeformOps.push_back(workingDeformOp);
			}

			NascentDeformStream result;
			result._rendererInterf._suppressedElements = workingSuppressedElements;
			for (const auto&wge:workingGeneratedElements)
				result._rendererInterf._suppressedElements.push_back(Hash64(wge.first._semantic) + wge.first._semanticIndex);		// (also suppress all elements generated by the final deform step, because they are effectively overriden)
			std::sort(result._rendererInterf._suppressedElements.begin(), result._rendererInterf._suppressedElements.end());
			result._rendererInterf._suppressedElements.erase(
				std::unique(result._rendererInterf._suppressedElements.begin(), result._rendererInterf._suppressedElements.end()),
				result._rendererInterf._suppressedElements.end());

			// Figure out how to arrange all of the input and output vertices in the 
			// deform VBs.
			// We've got 3 to use
			//		1. an input static data buffer; which contains values read directly from the source data (perhaps processed for format)
			//		2. a deform temporary buffer; which contains data written out from deform operations, and read in by others
			//		3. a final output buffer; which contains resulting vertex data that is fed into the render operation
			
			std::vector<SourceDataTransform> sourceDataTransforms;
			std::vector<DeformOp::Element> sourceDataStreams;
			{
				sourceDataTransforms.reserve(workingSourceDataElements.size());
				unsigned targetStride = 0, offsetIterator = 0;
				for (unsigned c=0; c<workingSourceDataElements.size(); ++c)
					targetStride += BitsPerPixel(workingSourceDataElements[c].first._format) / 8;
				for (unsigned c=0; c<workingSourceDataElements.size(); ++c) {
					const auto& workingE = workingSourceDataElements[c];
					sourceDataTransforms.push_back({
						geoId, Hash64(workingE.first._semantic) + workingE.first._semanticIndex,
						workingE.first._format, preDeformStaticDataVBIterator + offsetIterator, targetStride, vertexCount});
					sourceDataStreams.push_back({workingE.first._format, preDeformStaticDataVBIterator + offsetIterator, targetStride, VB_StaticData});
					offsetIterator += BitsPerPixel(workingE.first._format) / 8;
				}
				result._vbOffsets[VB_StaticData] = preDeformStaticDataVBIterator;
				result._vbSizes[VB_StaticData] = targetStride * vertexCount;
				preDeformStaticDataVBIterator += targetStride * vertexCount;
			}

			std::vector<DeformOp::Element> temporaryDataStreams;
			{
				temporaryDataStreams.reserve(workingTemporarySpaceElements.size());
				unsigned targetStride = 0, offsetIterator = 0;
				for (unsigned c=0; c<workingTemporarySpaceElements.size(); ++c)
					targetStride += BitsPerPixel(workingTemporarySpaceElements[c].first._format) / 8;
				for (unsigned c=0; c<workingTemporarySpaceElements.size(); ++c) {
					const auto& workingE = workingTemporarySpaceElements[c];
					temporaryDataStreams.push_back({workingE.first._format, deformTemporaryVBIterator + offsetIterator, targetStride, VB_TemporaryDeform});
					offsetIterator += BitsPerPixel(workingE.first._format) / 8;
				}
				result._vbOffsets[VB_TemporaryDeform] = deformTemporaryVBIterator;
				result._vbSizes[VB_TemporaryDeform] = targetStride * vertexCount;
				deformTemporaryVBIterator += targetStride * vertexCount;
			}

			std::vector<DeformOp::Element> generatedDataStreams;
			{
				generatedDataStreams.reserve(workingGeneratedElements.size());
				unsigned targetStride = 0, offsetIterator = 0;
				for (unsigned c=0; c<workingGeneratedElements.size(); ++c)
					targetStride += BitsPerPixel(workingGeneratedElements[c].first._format) / 8;
				for (unsigned c=0; c<workingGeneratedElements.size(); ++c) {
					const auto& workingE = workingGeneratedElements[c];
					generatedDataStreams.push_back({workingE.first._format, postDeformVBIterator + offsetIterator, targetStride, VB_PostDeform});
					offsetIterator += BitsPerPixel(workingE.first._format) / 8;
				}
				result._vbOffsets[VB_PostDeform] = postDeformVBIterator;
				result._vbSizes[VB_PostDeform] = targetStride * vertexCount;
				result._rendererInterf._vbOffset = postDeformVBIterator;
				postDeformVBIterator += targetStride * vertexCount;
			}

			// Collate the WorkingDeformOp into the SimpleModelRenderer::DeformOp format
			result._deformOps.reserve(workingDeformOps.size());
			for (const auto&wdo:workingDeformOps) {
				DeformOp finalDeformOp;
				// input streams
				for (auto s:wdo._inputStreamIds) {
					auto i = std::find_if(workingGeneratedElements.begin(), workingGeneratedElements.end(), [s](const std::pair<DeformOperationInstantiation::NameAndFormat, unsigned>& p) { return p.second == s; });
					if (i != workingGeneratedElements.end()) {
						finalDeformOp._inputElements.push_back(generatedDataStreams[i-workingGeneratedElements.begin()]);
					} else {
						i = std::find_if(workingTemporarySpaceElements.begin(), workingTemporarySpaceElements.end(), [s](const std::pair<DeformOperationInstantiation::NameAndFormat, unsigned>& p) { return p.second == s; });
						if (i != workingTemporarySpaceElements.end()) {
							finalDeformOp._inputElements.push_back(temporaryDataStreams[i-workingTemporarySpaceElements.begin()]);
						} else {
							i = std::find_if(workingSourceDataElements.begin(), workingSourceDataElements.end(), [s](const std::pair<DeformOperationInstantiation::NameAndFormat, unsigned>& p) { return p.second == s; });
							if (i != workingSourceDataElements.end()) {
								finalDeformOp._inputElements.push_back(sourceDataStreams[i-workingSourceDataElements.begin()]);
							} else {
								finalDeformOp._inputElements.push_back({});
							}
						}
					}
				}
				// output streams
				for (auto s:wdo._outputStreamIds) {
					auto i = std::find_if(workingGeneratedElements.begin(), workingGeneratedElements.end(), [s](const std::pair<DeformOperationInstantiation::NameAndFormat, unsigned>& p) { return p.second == s; });
					if (i != workingGeneratedElements.end()) {
						finalDeformOp._outputElements.push_back(generatedDataStreams[i-workingGeneratedElements.begin()]);
					} else {
						i = std::find_if(workingTemporarySpaceElements.begin(), workingTemporarySpaceElements.end(), [s](const std::pair<DeformOperationInstantiation::NameAndFormat, unsigned>& p) { return p.second == s; });
						if (i != workingTemporarySpaceElements.end()) {
							finalDeformOp._outputElements.push_back(temporaryDataStreams[i-workingTemporarySpaceElements.begin()]);
						} else {
							finalDeformOp._outputElements.push_back({});
						}
					}
				}
				finalDeformOp._deformOp = wdo._deformOp;
				result._deformOps.emplace_back(std::move(finalDeformOp));
			}

			result._rendererInterf._generatedElements.reserve(workingGeneratedElements.size());
			for (const auto&wge:workingGeneratedElements)
				result._rendererInterf._generatedElements.push_back(InputElementDesc{wge.first._semantic, wge.first._semanticIndex, wge.first._format});

			result._staticDataLoadRequests = std::move(sourceDataTransforms);

			return result;
		}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		static const RenderCore::Assets::VertexElement* FindElement(IteratorRange<const RenderCore::Assets::VertexElement*> ele, uint64_t semanticHash)
		{
			return std::find_if(
				ele.begin(), ele.end(),
				[semanticHash](const RenderCore::Assets::VertexElement& ele) {
					return (Hash64(ele._semanticName) + ele._semanticIndex) == semanticHash;
				});
		}

		static const RenderCore::Assets::VertexElement* FindElement(
			IteratorRange<const RenderCore::Assets::VertexElement*> ele,
			StringSection<> semantic, unsigned semanticIndex = 0)
		{
			auto i = std::find_if(
				ele.begin(), ele.end(),
				[semantic, semanticIndex](const RenderCore::Assets::VertexElement& ele) {
					return XlEqString(semantic, ele._semanticName) && ele._semanticIndex == semanticIndex;
				});
			if (i==ele.end())
				return nullptr;
			return i;
		}

		static IteratorRange<VertexElementIterator> AsVertexElementIteratorRange(
			IteratorRange<void*> vbData,
			const RenderCore::Assets::VertexElement& ele,
			unsigned vertexStride)
		{
			unsigned vCount = vbData.size() / vertexStride;
			auto beginPtr = PtrAdd(vbData.begin(), ele._alignedByteOffset);		
			auto endPtr = PtrAdd(vbData.begin(), ele._alignedByteOffset + vertexStride*vCount);
			VertexElementIterator begin {
				MakeIteratorRange(beginPtr, endPtr),
				vertexStride, ele._nativeFormat };
			VertexElementIterator end {
				MakeIteratorRange(endPtr, endPtr),
				vertexStride, ele._nativeFormat };
			return { begin, end };
		}

		static IteratorRange<VertexElementIterator> AsVertexElementIteratorRange(
			IteratorRange<void*> vbData,
			Format format,
			unsigned byteOffset,
			unsigned vertexStride)
		{
			unsigned vCount = vbData.size() / vertexStride;
			auto beginPtr = PtrAdd(vbData.begin(), byteOffset);
			auto endPtr = PtrAdd(vbData.begin(), byteOffset + vertexStride*vCount);
			VertexElementIterator begin { MakeIteratorRange(beginPtr, endPtr), vertexStride, format };
			VertexElementIterator end { MakeIteratorRange(endPtr, endPtr), vertexStride, format };
			return { begin, end };
		}

		static void ReadStaticData(
			IteratorRange<void*> destinationVB,
			IteratorRange<void*> sourceVB,
			const SourceDataTransform& transform,
			const RenderCore::Assets::VertexElement& srcElement,
			unsigned srcStride)
		{
			assert(destinationVB.size() >= transform._targetStride * transform._vertexCount);
			assert(sourceVB.size() >= srcStride * transform._vertexCount);
			auto dstRange = AsVertexElementIteratorRange(destinationVB, transform._targetFormat, transform._targetOffset, transform._targetStride);
			auto srcRange = AsVertexElementIteratorRange(sourceVB, srcElement._nativeFormat, srcElement._alignedByteOffset, srcStride);
			auto dstCount = dstRange.size();
			auto srcCount = srcRange.size();
			(void)dstCount; (void)srcCount;
			Assets::GeoProc::Copy(dstRange, srcRange, transform._vertexCount);
		}

		static std::vector<uint8_t> GenerateDeformStaticInput(
			const RenderCore::Assets::ModelScaffold& modelScaffold,
			IteratorRange<const SourceDataTransform*> inputLoadRequests,
			unsigned destinationBufferSize)
		{
			if (inputLoadRequests.empty())
				return {};

			std::vector<uint8_t> result;
			result.resize(destinationBufferSize, 0);

			std::vector<SourceDataTransform> loadRequests { inputLoadRequests.begin(), inputLoadRequests.end() };
			std::stable_sort(
				loadRequests.begin(), loadRequests.end(),
				[](const SourceDataTransform& lhs, const SourceDataTransform& rhs) {
					return lhs._geoId < rhs._geoId;
				});

			auto largeBlocks = modelScaffold.OpenLargeBlocks();
			auto base = largeBlocks->TellP();

			auto& immData = modelScaffold.ImmutableData();
			for (const auto&r:loadRequests) {
				bool initializedElement = false;
				if (r._geoId < immData._geoCount) {
					auto& geo = immData._geos[r._geoId];
					auto& vb = geo._vb;
					auto sourceEle = FindElement(MakeIteratorRange(vb._ia._elements), r._sourceStream);
					if (sourceEle != vb._ia._elements.end()) {
						auto vbData = std::make_unique<uint8_t[]>(vb._size);
						largeBlocks->Seek(base + vb._offset);
						largeBlocks->Read(vbData.get(), vb._size);
						ReadStaticData(MakeIteratorRange(result), MakeIteratorRange(vbData.get(), PtrAdd(vbData.get(), vb._size)), r, *sourceEle, vb._ia._vertexStride);
						initializedElement = true;
					}
				} else {
					auto& geo = immData._boundSkinnedControllers[r._geoId - immData._geoCount];
					auto sourceEle = FindElement(MakeIteratorRange(geo._vb._ia._elements), r._sourceStream);
					if (sourceEle != geo._vb._ia._elements.end()) {
						auto vbData = std::make_unique<uint8_t[]>(geo._vb._size);
						largeBlocks->Seek(base + geo._vb._offset);
						largeBlocks->Read(vbData.get(), geo._vb._size);
						ReadStaticData(MakeIteratorRange(result), MakeIteratorRange(vbData.get(), PtrAdd(vbData.get(), geo._vb._size)), r, *sourceEle, geo._animatedVertexElements._ia._vertexStride);
						initializedElement = true;
					} else {
						sourceEle = FindElement(MakeIteratorRange(geo._animatedVertexElements._ia._elements), r._sourceStream);
						if (sourceEle != geo._animatedVertexElements._ia._elements.end()) {
							auto vbData = std::make_unique<uint8_t[]>(geo._animatedVertexElements._size);
							largeBlocks->Seek(base + geo._animatedVertexElements._offset);
							largeBlocks->Read(vbData.get(), geo._animatedVertexElements._size);
							ReadStaticData(MakeIteratorRange(result), MakeIteratorRange(vbData.get(), PtrAdd(vbData.get(), geo._animatedVertexElements._size)), r, *sourceEle, geo._animatedVertexElements._ia._vertexStride);
							initializedElement = true;
						} else {
							sourceEle = FindElement(MakeIteratorRange(geo._skeletonBinding._ia._elements), r._sourceStream);
							if (sourceEle != geo._skeletonBinding._ia._elements.end()) {
								auto vbData = std::make_unique<uint8_t[]>(geo._skeletonBinding._size);
								largeBlocks->Seek(base + geo._skeletonBinding._offset);
								largeBlocks->Read(vbData.get(), geo._skeletonBinding._size);
								ReadStaticData(MakeIteratorRange(result), MakeIteratorRange(vbData.get(), PtrAdd(vbData.get(), geo._skeletonBinding._size)), r, *sourceEle, geo._skeletonBinding._ia._vertexStride);
								initializedElement = true;
							}
						}
					}
				}

				if (!initializedElement)
					Throw(std::runtime_error("Could not initialize deform input element"));
			}

			return result;
		}
    }
}}

