// Distributed under the MIT License (See
// accompanying file "LICENSE" or the website
// http://www.opensource.org/licenses/mit-license.php)

#pragma once

#include "SimpleModelDeform.h"
#include "../Format.h"
#include "../Types.h"
#include "../Assets/ModelScaffold.h"
#include "../Assets/ModelScaffoldInternal.h"
#include "../Assets/ModelImmutableData.h"
#include "../../Assets/IFileSystem.h"
#include "../GeoProc/MeshDatabase.h"        // for GeoProc::Copy
#include "../../Utility/MemoryUtils.h"
#include <memory>
#include <vector>

namespace RenderCore { namespace Techniques 
{
	namespace Internal
	{
		static constexpr unsigned VB_CPUStaticData = 0;
		static constexpr unsigned VB_CPUTemporaryDeform = 1;
		static constexpr unsigned VB_GPUTemporaryDeform = 2;
		static constexpr unsigned VB_PostDeform = 3;

		struct SourceDataTransform
		{
			unsigned	_geoId;
			uint64_t	_sourceStream;
			Format		_targetFormat;
			unsigned	_targetOffset;
			unsigned	_targetStride;
			unsigned	_vertexCount;
		};

		struct NascentDeformForGeo
		{
			struct CPUOp
			{
				std::shared_ptr<ICPUDeformOperator> _deformOp;
				struct Attribute { Format _format = Format(0); unsigned _offset = 0; unsigned _stride = 0; unsigned _vbIdx = ~0u; };
				std::vector<Attribute> _inputElements;
				std::vector<Attribute> _outputElements;
			};

			std::vector<CPUOp> _cpuOps;
			std::vector<::Assets::PtrToMarkerPtr<IGPUDeformOperator>> _gpuOps;

			RendererGeoDeformInterface _rendererInterf;
			std::vector<SourceDataTransform> _cpuStaticDataLoadRequests;

			unsigned _vbOffsets[4] = {0,0,0,0};
			unsigned _vbSizes[4] = {0,0,0,0};
		};

		static NascentDeformForGeo::CPUOp::Attribute AsCPUOpAttribute(const InputElementDesc& e, unsigned baseOffset, unsigned stride)
		{
			return {e._nativeFormat, baseOffset + e._alignedByteOffset, stride, VB_CPUTemporaryDeform};
		}

		/*static std::pair<std::vector<NascentDeformForGeo::CPUOp::Attribute>, unsigned> ArrangeAttributes(
			IteratorRange<const InputElementDesc*> attributes,
			unsigned baseOffset)
		{
			if (!attributes.size()) return {{}, 0};

			std::vector<NascentDeformForGeo::CPUOp::Attribute> result;
			result.reserve(attributes.size());
			auto stride = CalculateVertexStrideForSlot(attributes, attributes[0]._inputSlot);
			for (const auto&e:attributes) {
				assert(e._inputSlot == attributes[0]._inputSlot);	// expecting everything assigned to the same input slot
				result.push_back();
			}
			return {std::move(result), stride};
		}*/

		static NascentDeformForGeo BuildNascentDeformForGeo(
			IteratorRange<const DeformOperationInstantiation*> globalDeformAttachments,
			unsigned geoId,
			unsigned vertexCount,
			unsigned& preDeformStaticDataVBIterator,
			unsigned& deformTemporaryGPUVBIterator,
			unsigned& deformTemporaryCPUVBIterator,
			unsigned& postDeformVBIterator)
		{
			// Calculate which elements are suppressed by the deform operations
			std::vector<const DeformOperationInstantiation*> deformAttachments;
			for (const auto& def:globalDeformAttachments)
				if (def._geoId == geoId)
					deformAttachments.push_back(&def);
			if (!deformAttachments.size()) return {};

			std::vector<uint64_t> workingSuppressedElements;
			std::vector<InputElementDesc> workingGeneratedElements;

			std::vector<InputElementDesc> workingTemporarySpaceElements_cpu;
			std::vector<InputElementDesc> workingTemporarySpaceElements_gpu;
			std::vector<InputElementDesc> workingSourceDataElements_cpu;

			struct WorkingCPUDeformOp
			{
				std::shared_ptr<ICPUDeformOperator> _deformOp;
				std::vector<DeformOperationInstantiation::SemanticNameAndFormat> _inputStreamIds;
				std::vector<DeformOperationInstantiation::SemanticNameAndFormat> _outputStreamIds;
			};
			std::vector<WorkingCPUDeformOp> workingCPUDeformOps;

			struct WorkingGPUDeformOp
			{
				DeformOperationInstantiation::GPUDeformConstructorFN _constructor;
			};
			std::vector<WorkingGPUDeformOp> workingGPUDeformOps;

			for (auto d=deformAttachments.begin(); d!=deformAttachments.end(); ++d) {
				const auto&def = **d;
				assert((def._cpuOperator != nullptr) ^ (def._gpuConstructor != nullptr));		// we need either CPU or GPU style operator, but not both

				if (def._cpuOperator) {
					/////////////////// CPU type operator ///////////////////
					WorkingCPUDeformOp workingDeformOp;

					for (auto&e:def._upstreamSourceElements) {
						// find a matching source element generated from another deform op
						// (note that CPU operations can only take inputs from other CPU deforms)
						auto i = std::find_if(
							workingGeneratedElements.begin(), workingGeneratedElements.end(),
							[e](const auto& wge) {
								return wge._semanticName == e._semantic && wge._semanticIndex == e._semanticIndex;
							});
						if (i != workingGeneratedElements.end()) {
							workingTemporarySpaceElements_cpu.push_back(*i);
							workingGeneratedElements.erase(i);
						} else {
							// If it's not generated by some deform op, we look for it in the static data
							workingSourceDataElements_cpu.push_back(InputElementDesc{e._semantic, e._semanticIndex, e._format});
						}
					}

					// Before we add our own static data, we should remove any working elements that have been
					// suppressed
					auto i = std::remove_if(
						workingGeneratedElements.begin(), workingGeneratedElements.end(),
						[&def](const auto& wge) {
							auto hash = Hash64(wge._semanticName) + wge._semanticIndex;
							if (std::find(def._suppressElements.begin(), def._suppressElements.end(), hash) != def._suppressElements.end())
								return true;
							auto i = std::find_if(
								def._generatedElements.begin(), def._generatedElements.end(), 
								[&wge](const auto& e) { return e._semantic == wge._semanticName && e._semanticIndex == wge._semanticIndex; });
							return i != def._generatedElements.end();
						});
					workingGeneratedElements.erase(i, workingGeneratedElements.end());		// these get removed and don't go into temporary space. They are just never used

					for (const auto& e:def._generatedElements)
						workingGeneratedElements.push_back(InputElementDesc{e._semantic, e._semanticIndex, e._format});

					workingSuppressedElements.insert(
						workingSuppressedElements.end(),
						def._suppressElements.begin(), def._suppressElements.end());

					workingDeformOp._deformOp = std::move(def._cpuOperator);
					workingDeformOp._inputStreamIds = std::move(def._upstreamSourceElements);
					workingDeformOp._outputStreamIds = std::move(def._generatedElements);
					workingCPUDeformOps.push_back(workingDeformOp);
				} else {
					/////////////////// GPU type operator ///////////////////
					WorkingGPUDeformOp workingDeformOp;

					for (auto&e:def._upstreamSourceElements) {
						// find a matching source element generated from another deform op
						// (note that CPU operations can only take inputs from other CPU deforms)
						auto i = std::find_if(
							workingGeneratedElements.begin(), workingGeneratedElements.end(),
							[e](const auto& wge) {
								return wge._semanticName == e._semantic && wge._semanticIndex == e._semanticIndex;
							});
						if (i != workingGeneratedElements.end()) {
							workingTemporarySpaceElements_gpu.push_back(*i);
							workingGeneratedElements.erase(i);
						} // else it will just come from the static data
					}

					// Before we add our own static data, we should remove any working elements that have been
					// suppressed
					auto i = std::remove_if(
						workingGeneratedElements.begin(), workingGeneratedElements.end(),
						[&def](const auto& wge) {
							auto hash = Hash64(wge._semanticName) + wge._semanticIndex;
							if (std::find(def._suppressElements.begin(), def._suppressElements.end(), hash) != def._suppressElements.end())
								return true;
							auto i = std::find_if(
								def._generatedElements.begin(), def._generatedElements.end(), 
								[&wge](const auto& e) { return e._semantic == wge._semanticName && e._semanticIndex == wge._semanticIndex; });
							return i != def._generatedElements.end();
						});
					workingGeneratedElements.erase(i, workingGeneratedElements.end());		// these get removed and don't go into temporary space. They are just never used

					for (const auto& e:def._generatedElements)
						workingGeneratedElements.push_back(InputElementDesc{e._semantic, e._semanticIndex, e._format});

					workingSuppressedElements.insert(
						workingSuppressedElements.end(),
						def._suppressElements.begin(), def._suppressElements.end());

					workingDeformOp._constructor = std::move(def._gpuConstructor);
					workingGPUDeformOps.push_back(workingDeformOp);
				}
			}

			NascentDeformForGeo result;
			result._rendererInterf._suppressedElements = workingSuppressedElements;
			result._rendererInterf._suppressedElements.reserve(result._rendererInterf._suppressedElements.size() + workingGeneratedElements.size());
			for (const auto&wge:workingGeneratedElements)
				result._rendererInterf._suppressedElements.push_back(Hash64(wge._semanticName) + wge._semanticIndex);		// (also suppress all elements generated by the final deform step, because they are effectively overriden)
			std::sort(result._rendererInterf._suppressedElements.begin(), result._rendererInterf._suppressedElements.end());
			result._rendererInterf._suppressedElements.erase(
				std::unique(result._rendererInterf._suppressedElements.begin(), result._rendererInterf._suppressedElements.end()),
				result._rendererInterf._suppressedElements.end());

			workingGeneratedElements = NormalizeInputAssembly(workingGeneratedElements);
			workingTemporarySpaceElements_cpu = NormalizeInputAssembly(workingTemporarySpaceElements_cpu);
			workingTemporarySpaceElements_gpu = NormalizeInputAssembly(workingTemporarySpaceElements_gpu);
			workingSourceDataElements_cpu = NormalizeInputAssembly(workingSourceDataElements_cpu);

			for (auto&e:workingTemporarySpaceElements_cpu) e._inputSlot = VB_CPUTemporaryDeform;
			for (auto&e:workingTemporarySpaceElements_gpu) e._inputSlot = VB_GPUTemporaryDeform;
			for (auto&e:workingGeneratedElements) e._inputSlot = VB_PostDeform;
			for (auto&e:workingSourceDataElements_cpu) e._inputSlot = VB_CPUStaticData;

			// Figure out how to arrange all of the input and output vertices in the 
			// deform VBs.
			// We've got 3 to use
			//		1. an input static data buffer; which contains values read directly from the source data (perhaps processed for format)
			//		2. a deform temporary buffer; which contains data written out from deform operations, and read in by others
			//		3. a final output buffer; which contains resulting vertex data that is fed into the render operation
			
			unsigned vbStrides[4] = {0};
			{
				vbStrides[VB_CPUStaticData] = CalculateVertexStrideForSlot(workingSourceDataElements_cpu, VB_CPUStaticData);
				result._vbOffsets[VB_CPUStaticData] = preDeformStaticDataVBIterator;
				result._vbSizes[VB_CPUStaticData] = vbStrides[VB_CPUStaticData] * vertexCount;
				preDeformStaticDataVBIterator += vbStrides[VB_CPUStaticData] * vertexCount;

				result._cpuStaticDataLoadRequests.reserve(workingSourceDataElements_cpu.size());
				for (unsigned c=0; c<workingSourceDataElements_cpu.size(); ++c) {
					const auto& workingE = workingSourceDataElements_cpu[c];
					result._cpuStaticDataLoadRequests.push_back({
						geoId, Hash64(workingE._semanticName) + workingE._semanticIndex,
						workingE._nativeFormat, workingE._alignedByteOffset + result._vbOffsets[VB_CPUStaticData],
						vbStrides[VB_CPUStaticData], vertexCount});
				}
			}

			{
				vbStrides[VB_CPUTemporaryDeform] = CalculateVertexStrideForSlot(workingTemporarySpaceElements_cpu, VB_CPUTemporaryDeform);
				result._vbOffsets[VB_CPUTemporaryDeform] = deformTemporaryCPUVBIterator;
				result._vbSizes[VB_CPUTemporaryDeform] = vbStrides[VB_CPUTemporaryDeform] * vertexCount;
				deformTemporaryCPUVBIterator += vbStrides[VB_CPUTemporaryDeform] * vertexCount;
			}

			{
				vbStrides[VB_GPUTemporaryDeform] = CalculateVertexStrideForSlot(workingTemporarySpaceElements_gpu, VB_GPUTemporaryDeform);
				result._vbOffsets[VB_GPUTemporaryDeform] = deformTemporaryGPUVBIterator;
				result._vbSizes[VB_GPUTemporaryDeform] = vbStrides[VB_GPUTemporaryDeform] * vertexCount;
				deformTemporaryGPUVBIterator += vbStrides[VB_GPUTemporaryDeform] * vertexCount;
			}

			{
				vbStrides[VB_PostDeform] = CalculateVertexStrideForSlot(workingGeneratedElements, VB_PostDeform);
				result._vbOffsets[VB_PostDeform] = postDeformVBIterator;
				result._vbSizes[VB_PostDeform] = vbStrides[VB_PostDeform] * vertexCount;
				result._rendererInterf._vbOffset = postDeformVBIterator;
				postDeformVBIterator += vbStrides[VB_PostDeform] * vertexCount;
			}

			// Collate the WorkingDeformOp into the SimpleModelRenderer::DeformOp format
			result._cpuOps.reserve(workingCPUDeformOps.size());
			for (const auto&wdo:workingCPUDeformOps) {
				NascentDeformForGeo::CPUOp finalDeformOp;
				// input streams
				for (auto s:wdo._inputStreamIds) {
					auto i = std::find_if(workingTemporarySpaceElements_cpu.begin(), workingTemporarySpaceElements_cpu.end(), [s](const auto& p) { return p._semanticName == s._semantic && p._semanticIndex == s._semanticIndex; });
					if (i != workingTemporarySpaceElements_cpu.end()) {
						finalDeformOp._inputElements.push_back(AsCPUOpAttribute(*i, result._vbOffsets[VB_CPUTemporaryDeform], vbStrides[VB_CPUTemporaryDeform]));
					} else {
						i = std::find_if(workingSourceDataElements_cpu.begin(), workingSourceDataElements_cpu.end(), [s](const auto& p) { return p._semanticName == s._semantic && p._semanticIndex == s._semanticIndex; });
						if (i != workingSourceDataElements_cpu.end()) {
							finalDeformOp._inputElements.push_back(AsCPUOpAttribute(*i, result._vbOffsets[VB_CPUStaticData], vbStrides[VB_CPUStaticData]));
						} else {
							assert(0);
							finalDeformOp._inputElements.push_back({});
						}
					}
				}
				// output streams
				for (auto s:wdo._outputStreamIds) {
					auto i = std::find_if(workingGeneratedElements.begin(), workingGeneratedElements.end(), [s](const auto& p) { return p._semanticName == s._semantic && p._semanticIndex == s._semanticIndex; });
					if (i != workingGeneratedElements.end()) {
						finalDeformOp._outputElements.push_back(AsCPUOpAttribute(*i, result._vbOffsets[VB_PostDeform], vbStrides[VB_PostDeform]));
					} else {
						i = std::find_if(workingTemporarySpaceElements_cpu.begin(), workingTemporarySpaceElements_cpu.end(), [s](const auto& p) { return p._semanticName == s._semantic && p._semanticIndex == s._semanticIndex; });
						if (i != workingTemporarySpaceElements_cpu.end()) {
							finalDeformOp._outputElements.push_back(AsCPUOpAttribute(*i, result._vbOffsets[VB_CPUTemporaryDeform], vbStrides[VB_CPUTemporaryDeform]));
						} else {
							assert(0);
							finalDeformOp._outputElements.push_back({});
						}
					}
				}
				finalDeformOp._deformOp = wdo._deformOp;
				result._cpuOps.emplace_back(std::move(finalDeformOp));
			}

			result._rendererInterf._generatedElements = std::move(workingGeneratedElements);
			return result;
		}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		static const RenderCore::Assets::VertexElement* FindElement(IteratorRange<const RenderCore::Assets::VertexElement*> ele, uint64_t semanticHash)
		{
			return std::find_if(
				ele.begin(), ele.end(),
				[semanticHash](const RenderCore::Assets::VertexElement& ele) {
					return (Hash64(ele._semanticName) + ele._semanticIndex) == semanticHash;
				});
		}

		static const RenderCore::Assets::VertexElement* FindElement(
			IteratorRange<const RenderCore::Assets::VertexElement*> ele,
			StringSection<> semantic, unsigned semanticIndex = 0)
		{
			auto i = std::find_if(
				ele.begin(), ele.end(),
				[semantic, semanticIndex](const RenderCore::Assets::VertexElement& ele) {
					return XlEqString(semantic, ele._semanticName) && ele._semanticIndex == semanticIndex;
				});
			if (i==ele.end())
				return nullptr;
			return i;
		}

		static IteratorRange<VertexElementIterator> AsVertexElementIteratorRange(
			IteratorRange<void*> vbData,
			const RenderCore::Assets::VertexElement& ele,
			unsigned vertexStride)
		{
			unsigned vCount = vbData.size() / vertexStride;
			auto beginPtr = PtrAdd(vbData.begin(), ele._alignedByteOffset);		
			auto endPtr = PtrAdd(vbData.begin(), ele._alignedByteOffset + vertexStride*vCount);
			VertexElementIterator begin {
				MakeIteratorRange(beginPtr, endPtr),
				vertexStride, ele._nativeFormat };
			VertexElementIterator end {
				MakeIteratorRange(endPtr, endPtr),
				vertexStride, ele._nativeFormat };
			return { begin, end };
		}

		static IteratorRange<VertexElementIterator> AsVertexElementIteratorRange(
			IteratorRange<void*> vbData,
			Format format,
			unsigned byteOffset,
			unsigned vertexStride)
		{
			unsigned vCount = vbData.size() / vertexStride;
			auto beginPtr = PtrAdd(vbData.begin(), byteOffset);
			auto endPtr = PtrAdd(vbData.begin(), byteOffset + vertexStride*vCount);
			VertexElementIterator begin { MakeIteratorRange(beginPtr, endPtr), vertexStride, format };
			VertexElementIterator end { MakeIteratorRange(endPtr, endPtr), vertexStride, format };
			return { begin, end };
		}

		static void ReadStaticData(
			IteratorRange<void*> destinationVB,
			IteratorRange<void*> sourceVB,
			const SourceDataTransform& transform,
			const RenderCore::Assets::VertexElement& srcElement,
			unsigned srcStride)
		{
			assert(destinationVB.size() >= transform._targetStride * transform._vertexCount);
			assert(sourceVB.size() >= srcStride * transform._vertexCount);
			auto dstRange = AsVertexElementIteratorRange(destinationVB, transform._targetFormat, transform._targetOffset, transform._targetStride);
			auto srcRange = AsVertexElementIteratorRange(sourceVB, srcElement._nativeFormat, srcElement._alignedByteOffset, srcStride);
			auto dstCount = dstRange.size();
			auto srcCount = srcRange.size();
			(void)dstCount; (void)srcCount;
			Assets::GeoProc::Copy(dstRange, srcRange, transform._vertexCount);
		}

		static std::vector<uint8_t> GenerateDeformStaticInputForCPUDeform(
			const RenderCore::Assets::ModelScaffold& modelScaffold,
			IteratorRange<const SourceDataTransform*> inputLoadRequests,
			unsigned destinationBufferSize)
		{
			if (inputLoadRequests.empty())
				return {};

			std::vector<uint8_t> result;
			result.resize(destinationBufferSize, 0);

			std::vector<SourceDataTransform> loadRequests { inputLoadRequests.begin(), inputLoadRequests.end() };
			std::stable_sort(
				loadRequests.begin(), loadRequests.end(),
				[](const SourceDataTransform& lhs, const SourceDataTransform& rhs) {
					return lhs._geoId < rhs._geoId;
				});

			auto largeBlocks = modelScaffold.OpenLargeBlocks();
			auto base = largeBlocks->TellP();

			auto& immData = modelScaffold.ImmutableData();
			for (auto i=loadRequests.begin(); i!=loadRequests.end();) {

				auto start = i;
				while (i!=loadRequests.end() && i->_geoId == start->_geoId) ++i;
				auto end = i;

				if (start->_geoId < immData._geoCount) {
					auto& geo = immData._geos[start->_geoId];
					auto& vb = geo._vb;

					auto vbData = std::make_unique<uint8_t[]>(vb._size);
					largeBlocks->Seek(base + vb._offset);
					largeBlocks->Read(vbData.get(), vb._size);

					for (auto r=start; r!=end; ++r) {
						auto sourceEle = FindElement(MakeIteratorRange(vb._ia._elements), r->_sourceStream);
						if (sourceEle != vb._ia._elements.end()) {
							ReadStaticData(MakeIteratorRange(result), MakeIteratorRange(vbData.get(), PtrAdd(vbData.get(), vb._size)), *r, *sourceEle, vb._ia._vertexStride);
						} else
							Throw(std::runtime_error("Could not initialize deform input element"));
					}

				} else {
					auto& geo = immData._boundSkinnedControllers[start->_geoId - immData._geoCount];

					std::unique_ptr<uint8_t[]> baseVB;
					std::unique_ptr<uint8_t[]> animVB;
					std::unique_ptr<uint8_t[]> skelBindVB;

					for (auto r=start; r!=end; ++r) {
						auto sourceEle = FindElement(MakeIteratorRange(geo._vb._ia._elements), r->_sourceStream);

						if (sourceEle != geo._vb._ia._elements.end()) {
							if (!baseVB.get()) {
								baseVB = std::make_unique<uint8_t[]>(geo._vb._size);
								largeBlocks->Seek(base + geo._vb._offset);
								largeBlocks->Read(baseVB.get(), geo._vb._size);
							}
							ReadStaticData(MakeIteratorRange(result), MakeIteratorRange(baseVB.get(), PtrAdd(baseVB.get(), geo._vb._size)), *r, *sourceEle, geo._animatedVertexElements._ia._vertexStride);
						} else {
							sourceEle = FindElement(MakeIteratorRange(geo._animatedVertexElements._ia._elements), r->_sourceStream);
							if (sourceEle != geo._animatedVertexElements._ia._elements.end()) {
								if (!animVB.get()) {
									animVB = std::make_unique<uint8_t[]>(geo._animatedVertexElements._size);
									largeBlocks->Seek(base + geo._animatedVertexElements._offset);
									largeBlocks->Read(animVB.get(), geo._animatedVertexElements._size);
								}
								ReadStaticData(MakeIteratorRange(result), MakeIteratorRange(animVB.get(), PtrAdd(animVB.get(), geo._animatedVertexElements._size)), *r, *sourceEle, geo._animatedVertexElements._ia._vertexStride);
							} else {
								sourceEle = FindElement(MakeIteratorRange(geo._skeletonBinding._ia._elements), r->_sourceStream);
								if (sourceEle != geo._skeletonBinding._ia._elements.end()) {
									if (!skelBindVB.get()) {
										skelBindVB = std::make_unique<uint8_t[]>(geo._skeletonBinding._size);
										largeBlocks->Seek(base + geo._skeletonBinding._offset);
										largeBlocks->Read(skelBindVB.get(), geo._skeletonBinding._size);
									}
									ReadStaticData(MakeIteratorRange(result), MakeIteratorRange(skelBindVB.get(), PtrAdd(skelBindVB.get(), geo._skeletonBinding._size)), *r, *sourceEle, geo._skeletonBinding._ia._vertexStride);
								} else
									Throw(std::runtime_error("Could not initialize deform input element"));
							}
						}
					}
				}
			}

			return result;
		}
	}
}}

