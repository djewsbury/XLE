// Distributed under the MIT License (See
// accompanying file "LICENSE" or the website
// http://www.opensource.org/licenses/mit-license.php)

#pragma once

#include "DeformAccelerator.h"
#include "../../Assets/AssetsCore.h"
#include "../../Utility/IteratorUtils.h"
#include "../../Utility/StringUtils.h"
#include <vector>
#include <functional>
#include <future>

namespace RenderCore { namespace Assets { class ModelRendererConstruction; }}
namespace Formatters { template<typename T> class TextInputFormatter; }

namespace RenderCore { namespace Techniques 
{
	struct DeformOperationInstantiation
	{
		struct SemanticNameAndFormat { std::string _semantic; unsigned _semanticIndex; Format _format = Format(0); };
		std::vector<SemanticNameAndFormat> _generatedElements;			///< these are new elements generated by the deform operation
		std::vector<SemanticNameAndFormat> _upstreamSourceElements;		///< these are elements that are requested from some upstream source (either a previous deform operation or the static data)
		std::vector<uint64_t> _suppressElements;						///< hide these elements from downstream 

		friend bool operator==(const SemanticNameAndFormat& lhs, const SemanticNameAndFormat& rhs)
		{
			return (lhs._semantic == rhs._semantic) && (lhs._semanticIndex == rhs._semanticIndex) && (lhs._format == rhs._format);
		}
	};

	class IGeoDeformer;

	class DeformerConstruction : public std::enable_shared_from_this<DeformerConstruction>
	{
	public:
		void Add(
			::Assets::PtrToMarkerPtr<IGeoDeformer> deformer,
			DeformOperationInstantiation&& instantiation,
			unsigned elementIdx,
			unsigned geoIdx);

		void Add(
			std::shared_ptr<IGeoDeformer> deformer,
			DeformOperationInstantiation&& instantiation,
			unsigned elementIdx,
			unsigned geoIdx);

		void Add(
			std::shared_ptr<IDeformUniformsAttachment> deformer);

		Assets::ModelRendererConstruction& GetModelRendererConstruction() const;

		struct GeoEntry
		{
			std::shared_ptr<IGeoDeformer> _deformer;
			const DeformOperationInstantiation* _instantiation = nullptr;
			unsigned _elementIdx = ~0u;
			unsigned _geoIdx = ~0u;
		};
		std::vector<GeoEntry> GetGeoEntries() const;

		std::shared_ptr<IDeformUniformsAttachment> GetUniformsAttachment() const;
		std::shared_ptr<IDeformGeoAttachment> GetGeoAttachment() const;

		void FulfillWhenNotPending(std::promise<std::shared_ptr<DeformerConstruction>>&& promise);
		bool IsEmpty() const;
		uint64_t GetHash() const;

		DeformerConstruction(std::shared_ptr<IDevice> device, std::shared_ptr<Assets::ModelRendererConstruction> rendererConstruction);
		DeformerConstruction();
		~DeformerConstruction();
	private:
		bool _sealed = false;
		std::vector<::Assets::PtrToMarkerPtr<IGeoDeformer>> _deformerMarkers;
		std::vector<std::shared_ptr<IGeoDeformer>> _deformers;
		std::shared_ptr<IDevice> _device;
		std::shared_ptr<Assets::ModelRendererConstruction> _rendererConstruction;

		struct StoredGeoEntry
		{
			unsigned _elementIdx, _geoIdx;
			unsigned _deformerIdx;
			DeformOperationInstantiation _instantiation;
		};
		std::vector<StoredGeoEntry> _storedGeoEntries;

		struct StoredUniformsEntry
		{
			std::shared_ptr<IDeformUniformsAttachment> _deformer = nullptr;
		};
		StoredUniformsEntry _storedUniformsEntry;

		std::shared_ptr<IDeformGeoAttachment> _completedGeoAttachment;
	};

	// caller should wait on the renderer construction before calling DeserializeDeformerConstruction();
	std::shared_ptr<RenderCore::Techniques::DeformerConstruction> DeserializeDeformerConstruction(
		std::shared_ptr<RenderCore::IDevice>, std::shared_ptr<Assets::ModelRendererConstruction>, Formatters::TextInputFormatter<char>& cfg);

	template<typename Formatter>
		void DeserializeDeformerConstruction(
			RenderCore::Techniques::DeformerConstruction& dst,
			const RenderCore::Assets::ModelRendererConstruction&,
			Formatter&);

	class IDeformConfigure
	{
	public:
		virtual void Configure(
			DeformerConstruction& construction,
			Formatters::TextInputFormatter<char>& fmttr = EmptyFormatter()) = 0;
		virtual ~IDeformConfigure();

		static Formatters::TextInputFormatter<char>& EmptyFormatter();
	};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	inline std::shared_ptr<IDeformUniformsAttachment> DeformerConstruction::GetUniformsAttachment() const
	{
		// must have called FulfillWhenNotPending and waited on it before calling this
		return _storedUniformsEntry._deformer;
	}

	inline std::shared_ptr<IDeformGeoAttachment> DeformerConstruction::GetGeoAttachment() const
	{
		// must have called FulfillWhenNotPending and waited on it before calling this
		assert(_sealed);
		return _completedGeoAttachment;
	}

	inline bool DeformerConstruction::IsEmpty() const
	{
		return _storedGeoEntries.empty() && !_storedUniformsEntry._deformer;
	}

	inline Assets::ModelRendererConstruction& DeformerConstruction::GetModelRendererConstruction() const
	{
		assert(_rendererConstruction);
		return *_rendererConstruction;
	}

}}

