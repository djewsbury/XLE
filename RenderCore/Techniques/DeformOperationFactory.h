// Distributed under the MIT License (See
// accompanying file "LICENSE" or the website
// http://www.opensource.org/licenses/mit-license.php)

#pragma once

#include "DeformAccelerator.h"
#include "../../Assets/AssetsCore.h"
#include "../../Utility/IteratorUtils.h"
#include "../../Utility/StringUtils.h"
#include <vector>
#include <functional>
#include <future>

namespace RenderCore { namespace Assets { class ModelScaffold; }}

namespace RenderCore { namespace Techniques 
{
	struct DeformOperationInstantiation
	{
		struct SemanticNameAndFormat { std::string _semantic; unsigned _semanticIndex; Format _format = Format(0); };
		std::vector<SemanticNameAndFormat> _generatedElements;			///< these are new elements generated by the deform operation
		std::vector<SemanticNameAndFormat> _upstreamSourceElements;		///< these are elements that are requested from some upstream source (either a previous deform operation or the static data)
		std::vector<uint64_t> _suppressElements;						///< hide these elements from downstream 

		friend bool operator==(const SemanticNameAndFormat& lhs, const SemanticNameAndFormat& rhs)
		{
			return (lhs._semantic == rhs._semantic) && (lhs._semanticIndex == rhs._semanticIndex) && (lhs._format == rhs._format);
		}
	};

	class IGeoDeformer;

	class DeformerConstruction : public std::enable_shared_from_this<DeformerConstruction>
	{
	public:
		void Add(
			::Assets::PtrToMarkerPtr<IGeoDeformer> deformer,
			DeformOperationInstantiation&& instantiation,
			unsigned elementIdx,
			unsigned geoIdx);

		void Add(
			std::shared_ptr<IGeoDeformer> deformer,
			DeformOperationInstantiation&& instantiation,
			unsigned elementIdx,
			unsigned geoIdx);

		void Add(
			std::shared_ptr<IDeformUniformsAttachment> deformer);

		struct GeoEntry
		{
			std::shared_ptr<IGeoDeformer> _deformer;
			const DeformOperationInstantiation* _instantiation = nullptr;
			unsigned _elementIdx = ~0u;
			unsigned _geoIdx = ~0u;
		};
		std::vector<GeoEntry> GetGeoEntries() const;

		std::shared_ptr<IDeformUniformsAttachment> GetUniformsAttachment() const;

		void FulfillWhenNotPending(std::promise<std::shared_ptr<DeformerConstruction>>&& promise);
		bool IsEmpty() const;

		DeformerConstruction();
		~DeformerConstruction();
	private:
		bool _sealed = false;
		std::vector<::Assets::PtrToMarkerPtr<IGeoDeformer>> _deformerMarkers;
		std::vector<std::shared_ptr<IGeoDeformer>> _deformers;

		struct StoredGeoEntry
		{
			unsigned _elementIdx, _geoIdx;
			unsigned _deformerIdx;
			DeformOperationInstantiation _instantiation;
		};
		std::vector<StoredGeoEntry> _storedGeoEntries;

		struct StoredUniformsEntry
		{
			std::shared_ptr<IDeformUniformsAttachment> _deformer = nullptr;
		};
		StoredUniformsEntry _storedUniformsEntry;
	};

#if 0
	class IGeoDeformerFactory
	{
	public:
		virtual std::shared_ptr<IGeoDeformer> Configure(
			std::vector<DeformOperationInstantiation>& result,
			std::shared_ptr<RenderCore::Assets::ModelScaffoldCmdStreamForm> modelScaffold,
			const std::string& modelScaffoldName = {}) = 0;
		virtual void Bind(
			IGeoDeformer& op,
			const DeformerInputBinding& binding) = 0;
		virtual bool IsCPUDeformer() const = 0;
		
		virtual ~IGeoDeformerFactory();
	};

	class DeformOperationFactorySet
	{
	public:
		/*
		struct Deformer
		{
			std::vector<DeformOperationInstantiation> _instantiations;
			std::shared_ptr<IGeoDeformerFactory> _factory;
			std::shared_ptr<IGeoDeformer> _operator;
		};
		std::vector<Deformer> CreateDeformOperators(
			StringSection<> initializer,
			const std::shared_ptr<RenderCore::Assets::ModelScaffold>& modelScaffold,
			const std::string& modelScaffoldName);
		*/

		std::shared_ptr<IGeoDeformerFactory> GetFactory(uint64_t name) const;

		using RegisteredDeformId = uint32_t;
		RegisteredDeformId Register(StringSection<> name, std::shared_ptr<IGeoDeformerFactory>);
		void Deregister(RegisteredDeformId);
		
		static DeformOperationFactorySet& GetInstance();

		DeformOperationFactorySet();
		~DeformOperationFactorySet();
	private:
		struct RegisteredDeformOp
		{
			std::shared_ptr<IGeoDeformerFactory> _factory;
			RegisteredDeformId _deformId;
		};
		std::vector<std::pair<uint64_t, RegisteredDeformOp>> _instantiationFunctions;
		unsigned _nextDeformId;
	};
#endif

	class IGeoDeformerFactory
	{
	public:
		~IGeoDeformerFactory();
	};

	class DeformOperationFactorySet
	{
	public:
		std::shared_ptr<IGeoDeformerFactory> GetFactory(uint64_t name) const;

		using RegisteredDeformId = uint32_t;
		RegisteredDeformId Register(StringSection<> name, std::shared_ptr<IGeoDeformerFactory>);
		void Deregister(RegisteredDeformId);
		
		static DeformOperationFactorySet& GetInstance();

		DeformOperationFactorySet();
		~DeformOperationFactorySet();
	private:
		struct RegisteredDeformOp
		{
			std::shared_ptr<IGeoDeformerFactory> _factory;
			RegisteredDeformId _deformId;
		};
		std::vector<std::pair<uint64_t, RegisteredDeformOp>> _instantiationFunctions;
		unsigned _nextDeformId;
	};

}}

