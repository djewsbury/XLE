// Distributed under the MIT License (See
// accompanying file "LICENSE" or the website
// http://www.opensource.org/licenses/mit-license.php)

#pragma once

#include "../Types.h"
#include "../VertexUtil.h"
#include "../../Assets/AssetsCore.h"
#include "../../Utility/IteratorUtils.h"
#include "../../Utility/StringUtils.h"
#include <vector>
#include <functional>
#include <future>

namespace RenderCore { namespace Assets { class ModelScaffold; }}
namespace RenderCore { class IThreadContext; class IResourceView; }

namespace RenderCore { namespace Techniques 
{
	class ICPUDeformOperator
	{
	public:
		using VertexElementRange = IteratorRange<RenderCore::VertexElementIterator>;
		virtual void Execute(
			unsigned instanceIdx,
			IteratorRange<const VertexElementRange*> sourceElements,
			IteratorRange<const VertexElementRange*> destinationElements) const = 0;
		virtual void* QueryInterface(size_t) = 0;
		virtual ~ICPUDeformOperator();
	};

	class IGPUDeformOperator
	{
	public:
		virtual void ExecuteGPU(
			IThreadContext& threadContext,
			unsigned instanceIdx,
			const IResourceView& srcVB,
			const IResourceView& deformTemporariesVB,
			const IResourceView& dstVB) const = 0;
		virtual void* QueryInterface(size_t) = 0;
		virtual ::Assets::DependencyValidation GetDependencyValidation() = 0;
		virtual ~IGPUDeformOperator();
	};

	struct DeformerToRendererBinding
	{
		struct GeoBinding
		{
			unsigned _geoId = ~0u;
			std::vector<InputElementDesc> _generatedElements;
			std::vector<uint64_t> _suppressedElements;
			unsigned _postDeformBufferOffset = 0;
		};
		std::vector<GeoBinding> _geoBindings;
	};

	struct DeformerInputBinding
	{
		struct GeoBinding
		{
			unsigned _geoId = ~0u;
			IteratorRange<const InputElementDesc*> _srcElements;
			IteratorRange<const InputElementDesc*> _temporaryElements;
			IteratorRange<const InputElementDesc*> _generatedElements;
			unsigned _srcStride = 0;
			unsigned _temporariesStride = 0;
			unsigned _generatedStride = 0;
			unsigned _srcOffset = 0;
			unsigned _temporariesOffset = 0;
			unsigned _generatedOffset = 0;			
		};
		std::vector<GeoBinding> _geoBindings;
	};

	struct DeformOperationInstantiation
	{
		struct SemanticNameAndFormat { std::string _semantic; unsigned _semanticIndex; Format _format = Format(0); };
		std::vector<SemanticNameAndFormat> _generatedElements;			///< these are new elements generated by the deform operation
		std::vector<SemanticNameAndFormat> _upstreamSourceElements;		///< these are elements that are requested from some upstream source (either a previous deform operation or the static data)
		std::vector<uint64_t> _suppressElements;						///< hide these elements from downstream 
		unsigned _geoId = ~0u;

		friend bool operator==(const SemanticNameAndFormat& lhs, const SemanticNameAndFormat& rhs)
		{
			return (lhs._semantic == rhs._semantic) && (lhs._semanticIndex == rhs._semanticIndex) && (lhs._format == rhs._format);
		}
	};

	class IDeformOperationFactory
	{
	public:
		virtual std::shared_ptr<IGPUDeformOperator> Configure(
			std::vector<DeformOperationInstantiation>& result,
			StringSection<> initializer,
			std::shared_ptr<RenderCore::Assets::ModelScaffold> modelScaffold,
			const std::string& modelScaffoldName = {}) = 0;
		virtual void Bind(
			IGPUDeformOperator& op,
			const DeformerInputBinding& binding);
		
		virtual ~IDeformOperationFactory();
	};

	class DeformOperationFactorySet
	{
	public:
		using InstantiationSet = std::vector<DeformOperationInstantiation>;
		InstantiationSet CreateDeformOperations(
			StringSection<> initializer,
			const std::shared_ptr<RenderCore::Assets::ModelScaffold>& modelScaffold,
			const std::string& modelScaffoldName);

		using RegisteredDeformId = uint32_t;
		RegisteredDeformId Register(StringSection<> name, std::shared_ptr<IDeformOperationFactory>);
		void Deregister(RegisteredDeformId);
		
		static DeformOperationFactorySet& GetInstance();

		DeformOperationFactorySet();
		~DeformOperationFactorySet();
	private:
		struct RegisteredDeformOp
		{
			std::shared_ptr<IDeformOperationFactory> _factory;
			RegisteredDeformId _deformId;
		};
		std::vector<std::pair<uint64_t, RegisteredDeformOp>> _instantiationFunctions;
		unsigned _nextDeformId;
	};
}}

