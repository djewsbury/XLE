// Distributed under the MIT License (See
// accompanying file "LICENSE" or the website
// http://www.opensource.org/licenses/mit-license.php)

#pragma once

#include "../Types.h"
#include "../VertexUtil.h"
#include "../../Assets/AssetsCore.h"
#include "../../Utility/IteratorUtils.h"
#include "../../Utility/StringUtils.h"
#include <vector>
#include <functional>
#include <future>

namespace RenderCore { namespace Assets { class ModelScaffold; }}
namespace RenderCore { class IThreadContext; class IResourceView; }

namespace RenderCore { namespace Techniques 
{
	class IDeformer
	{
	public:
		virtual void ExecuteGPU(
			IThreadContext& threadContext,
			IteratorRange<const unsigned*> instanceIndices,
			unsigned outputInstanceStride,
			const IResourceView& srcVB,
			const IResourceView& deformTemporariesVB,
			const IResourceView& dstVB) const;

		using VertexElementRange = IteratorRange<RenderCore::VertexElementIterator>;
		virtual void ExecuteCPU(
			IteratorRange<const unsigned*> instanceIndices,
			unsigned outputInstanceStride,
			IteratorRange<const void*> srcVB,
			IteratorRange<const void*> deformTemporariesVB,
			IteratorRange<const void*> dstVB) const;

		virtual void* QueryInterface(size_t) = 0;
		virtual ~IDeformer();
	};

	struct DeformerToRendererBinding
	{
		struct GeoBinding
		{
			unsigned _geoId = ~0u;
			std::vector<InputElementDesc> _generatedElements;
			std::vector<uint64_t> _suppressedElements;
			unsigned _postDeformBufferOffset = 0;
		};
		std::vector<GeoBinding> _geoBindings;
	};

	struct DeformerInputBinding
	{
		struct GeoBinding
		{
			unsigned _geoId = ~0u;
			std::vector<InputElementDesc> _inputElements;		// use _inputSlot to indicate which buffer each element is within
			std::vector<InputElementDesc> _outputElements;		// use _inputSlot to indicate which buffer each element is within
			unsigned _bufferStrides[5];
			unsigned _bufferOffsets[5];
		};
		std::vector<GeoBinding> _geoBindings;
	};

	struct DeformOperationInstantiation
	{
		struct SemanticNameAndFormat { std::string _semantic; unsigned _semanticIndex; Format _format = Format(0); };
		std::vector<SemanticNameAndFormat> _generatedElements;			///< these are new elements generated by the deform operation
		std::vector<SemanticNameAndFormat> _upstreamSourceElements;		///< these are elements that are requested from some upstream source (either a previous deform operation or the static data)
		std::vector<uint64_t> _suppressElements;						///< hide these elements from downstream 
		unsigned _geoId = ~0u;

		friend bool operator==(const SemanticNameAndFormat& lhs, const SemanticNameAndFormat& rhs)
		{
			return (lhs._semantic == rhs._semantic) && (lhs._semanticIndex == rhs._semanticIndex) && (lhs._format == rhs._format);
		}
	};

	class IDeformOperationFactory
	{
	public:
		virtual std::shared_ptr<IDeformer> Configure(
			std::vector<DeformOperationInstantiation>& result,
			StringSection<> initializer,
			std::shared_ptr<RenderCore::Assets::ModelScaffold> modelScaffold,
			const std::string& modelScaffoldName = {}) = 0;
		virtual void Bind(
			IDeformer& op,
			const DeformerInputBinding& binding) = 0;
		virtual bool IsCPUDeformer() const = 0;
		
		virtual ~IDeformOperationFactory();
	};

	class DeformOperationFactorySet
	{
	public:
		struct Deformer
		{
			std::vector<DeformOperationInstantiation> _instantiations;
			std::shared_ptr<IDeformOperationFactory> _factory;
			std::shared_ptr<IDeformer> _operator;
		};
		std::vector<Deformer> CreateDeformOperators(
			StringSection<> initializer,
			const std::shared_ptr<RenderCore::Assets::ModelScaffold>& modelScaffold,
			const std::string& modelScaffoldName);

		using RegisteredDeformId = uint32_t;
		RegisteredDeformId Register(StringSection<> name, std::shared_ptr<IDeformOperationFactory>);
		void Deregister(RegisteredDeformId);
		
		static DeformOperationFactorySet& GetInstance();

		DeformOperationFactorySet();
		~DeformOperationFactorySet();
	private:
		struct RegisteredDeformOp
		{
			std::shared_ptr<IDeformOperationFactory> _factory;
			RegisteredDeformId _deformId;
		};
		std::vector<std::pair<uint64_t, RegisteredDeformOp>> _instantiationFunctions;
		unsigned _nextDeformId;
	};
}}

