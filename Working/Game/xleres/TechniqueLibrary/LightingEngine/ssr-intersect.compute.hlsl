
// Parts of this file is based on samples from GPUOpen; so reproducing the 
// copywrite notice here. We include libraries from AMD, which are included via git submodules
// that contain their licensing statements

/**********************************************************************
Copyright (c) 2020 Advanced Micro Devices, Inc. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
********************************************************************/

#include "ssr-common.hlsl"

// Scene & environment resources
Texture2D GBufferNormal;
Texture2D<float> DownsampleDepths;
TextureCube SkyCube;
Texture2D<int2> GBufferMotion;
Texture2D LastFrameLit;

// Resources generated by classify tiles
Buffer<uint> g_ray_list_read;
RWBuffer<uint> g_ray_counter;

// Outputs from this shader
RWTexture2D<float3> g_intersection_result;
#if SPLIT_CONFIDENCE
    RWTexture2D<float> g_confidence_result;
#endif

Buffer<uint> BN_Sobol;
Buffer<uint> BN_Ranking;
Buffer<uint> BN_Scrambling;

// Extra debugging products
#if DEBUGGING_PRODUCTS
    RWTexture2D<float> g_ray_lengths;
    RWTexture2D<float4> SSRDebug;
#endif

// Samplers / fixed resources
SamplerState TrilinearClampTransparentBlack;
SamplerState SkyCubeSampler;

#include "xleres/TechniqueLibrary/Framework/gbuffer.hlsl"
#include "xleres/TechniqueLibrary/LightingEngine/SpecularMethods.hlsl"

float3 FFX_SSSR_LoadNormal(int2 pixel_coordinate)
{
    return DecodeGBufferNormal(GBufferNormal.Load(int3(pixel_coordinate, 0)).xyz);
}

float FFX_SSSR_LoadDepth(int2 pixel_coordinate, int mip)
{
    return DownsampleDepths.Load(int3(pixel_coordinate, mip));
}

float3 SampleEnvironmentMap(float3 direction)
{
    return SkyCube.SampleLevel(SkyCubeSampler, direction, 0).xyz;
}

float3 LoadLitScene(uint2 coord, uint2 bufferDims, inout float confidence)
{
    // no protections for occclusions / disocclusions here
    int2 motion = GBufferMotion.Load(int3(coord.xy, 0)).rg;
    coord.xy += motion;
    [flatten] if (any(coord.xy >= bufferDims.xy)) {
        confidence = 0;
        return 0;
    }
    float3 result = LastFrameLit.Load(int3(coord, 0)).rgb;
    if (any(!isfinite(result))) {   // todo -- some values may be capping out and considered infinite here...? 
        confidence = 0;
        return 0;
    }
    return result;
}

float3 FFX_SSSR_ScreenSpaceToViewSpace(float3 screen_space_position)
{
    #if !defined(VULKAN)
        screen_space_position.y = (1 - screen_space_position.y);
    #endif
    screen_space_position.xy = 2 * screen_space_position.xy - 1;
    float4 result = mul(ClipToView, float4(screen_space_position, 1));
    return result.xyz/result.w;
}

float3 ScreenSpaceToWorldSpace(float3 screen_space_position)
{
    #if !defined(VULKAN)
        screen_space_position.y = (1 - screen_space_position.y);
    #endif
    screen_space_position.xy = 2 * screen_space_position.xy - 1;
    float4 result = mul(ClipToWorld, float4(screen_space_position, 1));
    return result.xyz/result.w;
}

// Transforms origin to uv space
// Mat must be able to transform origin from its current space into clip space.
float3 ProjectPosition(float3 origin, row_major float4x4 mat)
{
    float4 projected = mul(mat, float4(origin, 1));
    projected.xyz /= projected.w;
    projected.xy = 0.5 * projected.xy + 0.5;
    #if !defined(VULKAN)
        projected.y = (1 - projected.y);
    #endif
    return projected.xyz;
}

// Origin and direction must be in the same space and mat must be able to transform from that space into clip space.
float3 ProjectDirection(float3 origin, float3 direction, float3 screen_space_origin, row_major float4x4 mat)
{
    float3 offsetted = ProjectPosition(origin + direction, mat);
    return offsetted - screen_space_origin;
}

float VanderCorputRadicalInverse(uint bits)
{
    return float(reversebits(bits)) * 2.3283064365386963e-10f;
}

// Blue Noise Sampler by Eric Heitz. Returns a value in the range [0, 1].
float SampleRandomNumber(uint pixel_i, uint pixel_j, uint sample_index, uint sample_dimension) 
{
    // Wrap arguments
    pixel_i = pixel_i & 127u;
    pixel_j = pixel_j & 127u;
    sample_index = sample_index & 255u;
    sample_dimension = sample_dimension & 255u;

#ifndef SPP
#define SPP 8
#endif

#if SPP == 1
    const uint ranked_sample_index = sample_index ^ 0;
#else
    // xor index based on optimized ranking
    const uint ranked_sample_index = sample_index ^ BN_Ranking[sample_dimension + (pixel_i + pixel_j * 128u) * 8u];
#endif

    // Fetch value in sequence
    uint value = BN_Sobol[sample_dimension + ranked_sample_index * 256u];

    // If the dimension is optimized, xor sequence value based on optimized scrambling
    value = value ^ BN_Scrambling[(sample_dimension % 8u) + (pixel_i + pixel_j * 128u) * 8u];

    // Convert to float and return
    return (value + 0.5f) / 256.0f;
}

float3 SampleReflectionVector(float3 view_direction, float3 normal, float roughness, int2 dispatch_thread_id, out float weight)
{
#if 0
    // note -- it's really critical that there's as much variance in XY here as there will be across the entire
    //      "frameIdx" loop. We estimate the amount of reasonable temporal variance from the amount of spatial
    //      variance (after smoothing). If we under predict that, we will get a lot of extra noise and a strobing
    //      effect
    uint frameIdxScramble0[] = { 3, 1, 5, 0, 4, 2 };
    uint frameIdxScramble1[] = { 2, 6, 3, 4, 0, 5 };
    uint frameIdx = ((dispatch_thread_id.x+dispatch_thread_id.y)&1) ? frameIdxScramble0[FrameId%6] : frameIdxScramble1[FrameId%6];
    // uint frameIdx = FrameId%32;
    uint pattern = DitherPatternInt(dispatch_thread_id);
    uint i = (frameIdx*16)+(pattern*6);
    // uint i = frameIdx+(pattern*6);
    float theta = (i) / (16.0*6.0) * 2.0 * 3.14159;
    float phi = 0.01f + 0.035f * VanderCorputRadicalInverse(pattern);
    float2 variance = float2(cos(theta)*phi, sin(theta)*phi);
    normal = normalize(normal + float3(variance.x, variance.y, 0));
#elif 0
    float theta = 2.0f * 3.14159f * SampleRandomNumber(dispatch_thread_id.x, dispatch_thread_id.y, FrameId%8, 0);
    float scale = 0.0001f + 0.0175f * SampleRandomNumber(dispatch_thread_id.x, dispatch_thread_id.y, FrameId%8, 1);
    float2 variance = float2(cos(theta)*scale, sin(theta)*scale);
    normal = normalize(normal + float3(variance.x, variance.y, 0));
#elif 1
    float2 xi = float2(
        SampleRandomNumber(dispatch_thread_id.x, dispatch_thread_id.y, FrameId%8, 0),
        SampleRandomNumber(dispatch_thread_id.x, dispatch_thread_id.y, FrameId%8, 1));

    float alphad = RoughnessToDAlpha(roughness);
    float cosTheta = sqrt((1.f - xi.x) / (1.f + (alphad*alphad - 1.f) * xi.x));

    float sinTheta = sqrt(1.f - cosTheta * cosTheta);
    float phi = 2.f * 3.14159 * xi.y;

    float3 Q;
    Q.x = sinTheta * cos(phi);
    Q.y = sinTheta * sin(phi);
    Q.z = cosTheta;

    // we're just building a tangent frame to give meaning to theta and phi...
    float3 up = (abs(normal.x) < 0.5f) ? float3(1,0,0) : float3(0,1,0);
    float3 tangentX = normalize(cross(up, normal));
    float3 tangentY = cross(normal, tangentX);
    float3 H = tangentX * Q.x + tangentY * Q.y + normal * Q.z;
    float NdotH = abs(dot(H, normal));
    float3 V = -view_direction;
    float VdotH = abs(dot(V, H));

    float3 L = 2.f * dot(V, H) * H - V;

    // todo -- this needs a lot of optimization
    float D = TrowReitzD(NdotH, alphad);
    weight = (4.f * VdotH) / (D * NdotH);
    const float3 F0 = 0.1.xxx;
    weight *= ReferenceSpecularGGX(normal, V, L, H, roughness, F0, false).r;
    return L;
#endif

    weight = 1;
    return reflect(view_direction, normal);

    /*float3x3 tbn_transform = CreateTBN(normal);
    float3 view_direction_tbn = mul(-view_direction, tbn_transform);

    float2 u = SampleRandomVector2D(dispatch_thread_id);
    
    float3 sampled_normal_tbn = Sample_GGX_VNDF_Hemisphere(view_direction_tbn, roughness, u.x, u.y);
    #ifdef PERFECT_REFLECTIONS
        sampled_normal_tbn = float3(0, 0, 1); // Overwrite normal sample to produce perfect reflection.
    #endif
    
    float3 reflected_direction_tbn = reflect(-view_direction_tbn, sampled_normal_tbn);

    // Transform reflected_direction back to the initial space.
    float3x3 inv_tbn_transform = transpose(tbn_transform);
    return mul(reflected_direction_tbn, inv_tbn_transform);*/
}

bool IsMirrorReflection(float roughness) { return false; }

#define FFX_SSSR_INVERTED_DEPTH_RANGE       // note -- set in ReverseZ modes
#include "xleres/Foreign/ffx-sssr/ffx_sssr.h"

void UnpackRayCoords(uint packed, out uint2 ray_coord, out bool copy_horizontal, out bool copy_vertical, out bool copy_diagonal) {
    ray_coord.x = (packed >> 0) & 0b111111111111111;
    ray_coord.y = (packed >> 15) & 0b11111111111111;
    copy_horizontal = (packed >> 29) & 0b1;
    copy_vertical = (packed >> 30) & 0b1;
    copy_diagonal = (packed >> 31) & 0b1;
}

[numthreads(8, 8, 1)]
    void SSRIntersect(uint group_index : SV_GroupIndex, uint group_id : SV_GroupID) 
{
    uint ray_index = group_id * 64 + group_index;
    if (ray_index >= g_ray_counter[1]) return;
    uint packed_coords = g_ray_list_read[ray_index];
    
    int2 coords;
    bool copy_horizontal;
    bool copy_vertical;
    bool copy_diagonal;
    UnpackRayCoords(packed_coords, coords, copy_horizontal, copy_vertical, copy_diagonal);

    uint2 screen_size;
    g_intersection_result.GetDimensions(screen_size.x, screen_size.y);

    float2 uv = (coords + 0.5) / screen_size;

    float3 world_space_normal = FFX_SSSR_LoadNormal(coords);
    float roughness = GBufferNormal.Load(int3(coords, 0)).a;
    bool is_mirror = IsMirrorReflection(roughness);

    float world_ray_length = 0;
    float3 reflection_radiance = 0;

    int most_detailed_mip = is_mirror ? 0 : g_most_detailed_mip;
    float2 mip_resolution = FFX_SSSR_GetMipResolution(screen_size, most_detailed_mip);
    float z = FFX_SSSR_LoadDepth(uv * mip_resolution, most_detailed_mip);
    float4 debugOutput = 0;
    float confidence;
    {
        float3 screen_uv_space_ray_origin = float3(uv, z);
        float3 view_space_ray = FFX_SSSR_ScreenSpaceToViewSpace(screen_uv_space_ray_origin);
        float3 view_space_ray_direction = normalize(view_space_ray);

        float weight = 1;
        float3 view_space_surface_normal = mul(WorldToView, float4(world_space_normal, 0)).xyz;  // assuming uniform scale on world->view
        float3 view_space_reflected_direction = SampleReflectionVector(view_space_ray_direction, view_space_surface_normal, roughness, coords, weight);
        float3 screen_space_ray_direction = ProjectDirection(view_space_ray, view_space_reflected_direction, screen_uv_space_ray_origin, ViewToProj);
        float3 world_space_reflected_direction = mul(ViewToWorld, float4(view_space_reflected_direction, 0)).xyz;
        
        //====SSSR====
        bool valid_hit = false;
        float3 hit = FFX_SSSR_HierarchicalRaymarch(screen_uv_space_ray_origin, screen_space_ray_direction, is_mirror, screen_size, most_detailed_mip, g_min_traversal_occupancy, g_max_traversal_intersections, valid_hit);

        float3 world_space_origin   = ScreenSpaceToWorldSpace(screen_uv_space_ray_origin);
        float3 world_space_hit      = ScreenSpaceToWorldSpace(hit);
        float3 world_space_ray      = world_space_hit - world_space_origin.xyz;

        float depthBufferThickness = g_depth_buffer_thickness;
        confidence = valid_hit ? FFX_SSSR_ValidateHit(hit, uv, world_space_ray, screen_size, depthBufferThickness) : 0;
        world_ray_length = length(world_space_ray);
        
        if (confidence > 0) {
            // Found an intersection with the depth buffer -> We can lookup the color from lit scene.
            reflection_radiance = LoadLitScene(screen_size * hit.xy, screen_size, confidence);
        }

        debugOutput = float4(roughness.xxx, 1);

        #if !SPLIT_CONFIDENCE
            // Sample environment map.
            // It's not ideal to do this here, because this sample doesn't work well with the temporal denoising when there is motion, since 
            // we're reflecting an infinitely distant object. Denoising attempting to reproject a past surface position, as the camera moves
            // the reflection will shift on the object as well, so the sample from the reprojected position will be poor... However that's not
            // such a big issue for reflections of nearby surfaces.
            // Instead let's store and denoise a confidence value along with the color value
            float3 environment_lookup = SampleEnvironmentMap(world_space_reflected_direction);
            reflection_radiance = confidence * reflection_radiance + (1 - confidence) * environment_lookup;
            reflection_radiance *= weight;
        #endif

        // protect against zero length normals (which we can sometimes run into, and which will result in nans)
        if (all(world_space_normal == 0)) {
            reflection_radiance = 0;
            confidence = 0;
        }
    }

    g_intersection_result[coords] = reflection_radiance;
    #if SPLIT_CONFIDENCE
        g_confidence_result[coords] = confidence;
    #endif
    #if DEBUGGING_PRODUCTS
        g_ray_lengths[coords] = world_ray_length;
        SSRDebug[coords] = debugOutput;
    #endif

    uint2 copy_target = coords ^ 0b1; // Flip last bit to find the mirrored coords along the x and y axis within a quad.
    if (copy_horizontal) {
        uint2 copy_coords = uint2(copy_target.x, coords.y);
        g_intersection_result[copy_coords] = reflection_radiance;
        #if SPLIT_CONFIDENCE
            g_confidence_result[copy_coords] = confidence;
        #endif
        #if DEBUGGING_PRODUCTS
            g_ray_lengths[copy_coords] = world_ray_length;
            SSRDebug[copy_coords] = debugOutput;
        #endif
    }
    if (copy_vertical) {
        uint2 copy_coords = uint2(coords.x, copy_target.y);
        g_intersection_result[copy_coords] = reflection_radiance;
        #if SPLIT_CONFIDENCE
            g_confidence_result[copy_coords] = confidence;
        #endif
        #if DEBUGGING_PRODUCTS
            g_ray_lengths[copy_coords] = world_ray_length;
            SSRDebug[copy_coords] = debugOutput;
        #endif
    }
    if (copy_diagonal) {
        uint2 copy_coords = copy_target;
        g_intersection_result[copy_coords] = reflection_radiance;
        #if SPLIT_CONFIDENCE
            g_confidence_result[copy_coords] = confidence;
        #endif
        #if DEBUGGING_PRODUCTS
            g_ray_lengths[copy_coords] = world_ray_length;
            SSRDebug[copy_coords] = debugOutput;
        #endif
    }
}

